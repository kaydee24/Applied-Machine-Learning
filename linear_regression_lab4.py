# -*- coding: utf-8 -*-
"""Linear Regression_LAB4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q6SUd700RqPV7atKXYTIKISaqtBn5Y-e
"""

##This block is only for access of files using google drive
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

#For accessing any file from google drive, first share it for public access. Copy its id from last part of its address. Then specify the two lines below.
downloaded = drive.CreateFile({'id':"1M8ZhsATiJGFX1iLg13iWZB_3CC_WExJb"})   # replace the id with id of file you want to access
downloaded.GetContentFile('auto-mpg.csv')        # replace the file name with your file

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

cars=pd.read_csv('auto-mpg.csv')

cars['car name'] = cars['car name'].apply(lambda x:x.split(' ')[0])  # Save only the brand name in car name column

cars['car name'].unique()  # Find unique car brand names

#correct errors in data entry
cars['car name'].replace('maxda','mazda', inplace=True)
cars['car name'].replace('toyouta','toyota', inplace=True)
cars['car name'].replace('vokswagen','volkswagen', inplace=True)
cars['car name'].replace('vw','volkswagen', inplace=True)
cars['car name'].replace('chevy','chevrolet', inplace=True)

#Convert text categories of brand names to codes
cars['car name']= cars['car name'].astype('category').cat.codes

import seaborn as sns
correlation_matrix=cars.corr().round(2)
sns.heatmap(data=correlation_matrix,annot=True)
#From the correlation matrix identify strongest correlators to mpg

#Strong correlation of mpg with cylinder, displacement and weight very small correlation with brand name
import matplotlib.pyplot as plt
plt.figure(figsize = [20,5])
plt.subplot(1,4,1)
plt.scatter(cars['cylinders'],cars['mpg'])
plt.xlabel('cylinders')
plt.ylabel('mpg')
plt.title('abcd')


plt.subplot(1,4,2)
plt.scatter(cars['weight'],cars['mpg'])
plt.xlabel('weight')
plt.ylabel('mpg')

plt.subplot(1,4,3)
plt.scatter(cars['displacement'],cars['mpg'])
plt.xlabel('displacement')
plt.ylabel('mpg')

plt.subplot(1,4,4)
plt.scatter(cars['car name'],cars['mpg'])
plt.xlabel('car name')
plt.ylabel('mpg')

#Distribution of mpg
sns.distplot(cars['mpg'])

#Create the training set
#Shuffle and copy 200 rows. Extract the mpg row as the target (train_sety)
from sklearn.utils import shuffle
cars = shuffle(cars)
train_Set = cars[:200]
train_sety = train_Set['mpg'];
train_setx = train_Set.drop(columns = ['mpg'])

#Create the test set
#copy alls rows after 200. Extract the mpg row as the target (test_sety)
test_Set = cars[200:]
test_sety = test_Set['mpg'];
test_setx = test_Set.drop(columns = ['mpg'])

import random
random.seed(1)
theta0 = random.uniform(-1,1);
theta1 = random.uniform(-1,1);
theta2 = random.uniform(-1,1);

import numpy as np
X1 = train_setx['weight'];
X2 = np.square(train_setx['weight'])

M1= np.mean(X1);
S1 = np.std(X1);
X1 = (X1 - M1)/S1;

M2= np.mean(X2);
S2 = np.std(X2);
X2 = (X2 - M2)/S2;

Y = train_sety
L = len(X1)
alpha = 0.5;

iteration_Nos = range(1, 150)
err_F = [None] * len(iteration_Nos)

for i in iteration_Nos:
    h = ((1/L)*np.sum(np.square(theta0 + theta1*X1 + theta2*X2 - Y)))
    err_F[i-1] = h;
    theta0 = theta0 - (alpha/L)*np.sum((2*(theta0 + theta1*X1 + theta2*X2 - Y)));
    theta1 = theta1 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 - Y),X1));
    theta2 = theta2 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 - Y),X2));

    plt.clf()
    plt.subplot(1,2,1);
    plt.plot(range(1, i), err_F[1:i])
    plt.xlabel('Iteration No.')
    plt.ylabel('Cost')
    
    plt.subplot(1,2,2);
    plt.scatter(X1, Y)
    X_R = np.arange(np.min(train_setx['weight']),np.max(train_setx['weight']), 0.1);
    # create a x axis with  min to max
    X_R2 = np.square(X_R);
    X_R = (X_R-M1)/S1;
    X_R2 = (X_R2 - M2)/S2;
    plt.plot(X_R, theta0 + theta1*X_R+ theta2*X_R2, 'r');
    plt.show()
    #ploting the red line
    print('Error = ',h, 'theta0 = ', theta0, 'theta1 = ', theta1, 'theta2 = ', theta2,'\n')

y_Train = pd.DataFrame()
x_Train = pd.DataFrame()
x_Train['weight'] = train_Set['weight'].copy()
x_Train['displacement'] = train_Set['displacement'].copy()
x_Train['weight_sqr'] = np.square(train_Set['weight'].copy())
x_Train['displacement_Sqr'] = np.square(train_Set['displacement'].copy())
y_Train['mpg'] = train_Set['mpg'].copy()


x_Test = pd.DataFrame()
y_Test = pd.DataFrame()
x_Test['weight'] = test_Set['weight'].copy()
x_Test['displacement'] = test_Set['displacement'].copy()
x_Test['weight_sqr'] = np.square(test_Set['weight'].copy())
x_Test['displacement_Sqr'] = np.square(test_Set['displacement'].copy())
y_Test['mpg'] = test_Set['mpg'].copy()

#Preprocessing and initialization
import random
random.seed(1)
theta0 = random.uniform(-1,1);
theta1 = random.uniform(-1,1);
theta2 = random.uniform(-1,1);
theta3 = random.uniform(-1,1);
theta4 = random.uniform(-1,1);

import numpy as np
X1 = x_Train['weight'].copy()
X2 = x_Train['displacement'].copy()
X3 = x_Train['weight_sqr'].copy()
X4 = x_Train['displacement_Sqr'].copy()

X1_ = x_Test['weight'].copy()
X2_ = x_Test['displacement'].copy()
X3_ = x_Test['weight_sqr'].copy()
X4_ = x_Test['displacement_Sqr'].copy()

X1 = (X1 - np.mean(X1))/np.std(X1);
X2 = (X2 - np.mean(X2))/np.std(X2);
X3 = (X3 - np.mean(X3))/np.std(X3);
X4 = (X4 - np.mean(X4))/np.std(X4);

X1_ = (X1_ - np.mean(X1_))/np.std(X1_);
X2_ = (X2_ - np.mean(X2_))/np.std(X2_);
X3_ = (X3_ - np.mean(X3_))/np.std(X3_);
X4_ = (X4_ - np.mean(X4_))/np.std(X4_);

Y_train = train_Set['mpg'].copy()
Y_test  = test_Set['mpg'].copy()
L = len(X1)

alpha = 0.3;
iterations = 1000
iteration_Nos = range(0, iterations)
train_err = [None] * len(iteration_Nos)
test_err  = [None] * len(iteration_Nos)
########################### Training
for i in iteration_Nos:
    trainerr = np.sqrt((1/L)*np.sum(np.square(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4 - Y_train)))
    testerr  = np.sqrt((1/L)*np.sum(np.square(theta0 + theta1*X1_ + theta2*X2_ + theta3*X3_ + theta4*X4_ - Y_test)))
    train_err[i] = trainerr;
    test_err[i] = testerr;

    theta0 = theta0 - (alpha/L)*np.sum((2*(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4  - Y)));
    theta1 = theta1 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4 - Y),(X1) ));
    theta2 = theta2 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4 - Y),(X2) ));
    theta3 = theta3 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4 - Y),(X3) ));
    theta4 = theta4 - (alpha/L)*np.sum(np.multiply(2*(theta0 + theta1*X1 + theta2*X2 + theta3*X3 + theta4*X4 - Y),(X4) ));

plt.clf()
plt.plot(iteration_Nos,train_err,label = 'train')
plt.plot(iteration_Nos,test_err,label = 'test')
plt.xlabel('iteration')
plt.ylabel('rmse error')
plt.legend()
plt.show()

#QUESTION_4.2:
x_Train = pd.DataFrame()                                                        #collecting the training data from DataFrame
x_Train['weight'] = train_Set['weight']                                         #storing values of weight from training data set
x_Train['displacement'] = train_Set['displacement']                             #storing values of displacement from training data set      
x_Train['weight_sqr'] = np.square(train_Set['weight'])                          # computing square of weight
x_Train['displacement_Sqr'] = np.square(train_Set['displacement'])              # computing square of displacement

x_Test = pd.DataFrame()                                                         #collecting the test data from DataFrame      
x_Test['weight'] = test_Set['weight']                                           #storing values of weight from test data set
x_Test['displacement'] = test_Set['displacement']                               #storing values of displacement from test data set
x_Test['weight_sqr'] = np.square(test_Set['weight'])                            # computing square of weight
x_Test['displacement_Sqr'] = np.square(test_Set['displacement'])                # computing square of displacement

from sklearn.linear_model import LinearRegression                               # importing LinearRegression prediction model from library sklearn
from sklearn.metrics import mean_squared_error, r2_score                        # importing mean square eroor and r2_score from library sklearn

lin_model = LinearRegression()                                                  # making linear regression model
lin_model.fit(x_Train, train_sety)                                              #training the model

y_train_predict = lin_model.predict(x_Train)                                    # predicting y for trained model
rmse = (np.sqrt(mean_squared_error(train_sety, y_train_predict)))               # finding root mean square error
r2 = r2_score(train_sety, y_train_predict)                                      # calculating R^2 score for training model

print("The model performance for training set")                                 # printing the required values
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")


y_test_predict = lin_model.predict(x_Test)                                      # predicting y for trained model  
rmse = (np.sqrt(mean_squared_error(test_sety, y_test_predict)))                 # finding root mean square error
r2 = r2_score(test_sety, y_test_predict)                                        # calculating R^2 score for test model      

print("The model performance for testing set")                                  # printing the required values
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

#Question_4.3
predict_x = x_Test.iloc[4].copy()
actual_y  = test_sety.iloc[4]
predicted_y = lin_model.predict([predict_x])
print(predict_x)
print("-")
print(actual_y)
print("-")
print(predicted_y[0])
'''
Difference is of approx 4
'''

#Question_4.4:

def normalize(X):
  x_norm = (X-np.mean(X))/np.std(X);
  return x_norm;  
Y = test_sety
x1 = train_Set['displacement'];
X1 = normalize(train_Set['displacement']);
x2 = np.square(x1);
X2 = normalize(x2);
x3 = train_Set['weight'];
X3 = normalize(train_Set['weight']);
x4 = np.square(x3);
X4 = normalize(x4);
L = len(X1);
X0 = np.ones((1,L));

# Applying normal equation 
Xn = np.dstack((X0,X1,X2,X3,X4));
Xn = Xn.reshape(L,5);
#Xntrans = np.transpose(Xn);
xtemp1 = np.dot(Xn.T,Xn);
#xtemp2 = np.linalg.inv(xtemp1);
xtemp3 = np.dot(Xn.T,Yn);
thetan = np.dot(np.linalg.inv(xtemp1),xtemp3);

#print(thetan);
print('theta0 = ',thetan[0], 'theta1 = ', thetan[1], 'theta2 = ', thetan[2],'theta3 = ', thetan[3], 'theta4 = ', thetan[4],'\n')


plt.plot(thetan,'rp',label='Normal Eq. theta')
plt.plot([theta0,theta1,theta2,theta3,theta4],'bp',label='Gradient Descent theta')
plt.legend()

